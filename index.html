<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Les Aiguilles Blanches - Snow Groomer Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #1a1a2e;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #e8f4f8;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* HUD Overlay */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }
        
        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: auto;
        }
        
        .hud-panel.high-contrast {
            background: #000;
            border: 2px solid #fff;
        }
        
        /* Touch Controls */
        #touchControls {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            padding: 0 20px;
            justify-content: space-between;
            align-items: flex-end;
            z-index: 20;
        }
        
        .touch-joystick {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            position: relative;
        }
        
        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .touch-buttons {
            display: flex;
            gap: 10px;
        }
        
        .touch-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .touch-btn.active {
            background: rgba(255, 255, 255, 0.6);
        }
        
        /* Menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #fff;
        }
        
        .hidden {
            display: none !important;
        }
        
        .menu-title {
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 3px 3px 0 #2d5a7b;
            text-align: center;
        }
        
        .menu-subtitle {
            font-size: 18px;
            margin-bottom: 40px;
            color: #aaa;
        }
        
        .menu-btn {
            background: #2d5a7b;
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-family: inherit;
            cursor: pointer;
            margin: 5px;
            border-radius: 4px;
            min-width: 200px;
        }
        
        .menu-btn:hover, .menu-btn:focus {
            background: #3d7a9b;
            outline: 3px solid #fff;
        }
        
        .menu-btn.rebinding {
            background: #ff6600;
            animation: pulse 0.5s infinite alternate;
        }
        
        @keyframes pulse {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        
        /* Settings Panel */
        .settings-panel {
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .settings-section {
            margin-bottom: 20px;
        }
        
        .settings-section h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
        
        .setting-row label {
            flex: 1;
        }
        
        .setting-row select, .setting-row input {
            padding: 5px 10px;
            font-family: inherit;
            font-size: 14px;
        }
        
        /* Dialogue Box */
        #dialogueBox {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            z-index: 50;
            display: none;
        }
        
        #dialogueBox.visible {
            display: block;
        }
        
        .dialogue-speaker {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .dialogue-text {
            line-height: 1.5;
        }
        
        /* Level Complete */
        .level-complete {
            text-align: center;
        }
        
        .level-complete h2 {
            font-size: 36px;
            color: #4CAF50;
            margin-bottom: 20px;
        }
        
        .stats {
            margin: 20px 0;
            font-size: 18px;
        }
        
        .stats div {
            margin: 10px 0;
        }
        
        /* Screen Reader Only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        
        /* Responsive */
        @media (max-width: 600px) {
            .menu-title {
                font-size: 28px;
            }
            .hud-panel {
                font-size: 12px;
                padding: 6px 8px;
            }
            #touchControls {
                display: flex;
            }
        }
        
        @media (pointer: coarse) {
            #touchControls {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <!-- Screen Reader Announcements -->
    <div id="srAnnounce" class="sr-only" aria-live="polite" aria-atomic="true"></div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" role="img" aria-label="Game view of Les Aiguilles Blanches ski resort"></canvas>
        
        <!-- HUD -->
        <div id="hud" role="status" aria-label="Game status">
            <div class="hud-panel" id="levelInfo">
                <div id="levelName">Level 1: Green Piste</div>
                <div id="levelTask">Groom the beginner slope</div>
            </div>
            <div class="hud-panel" id="statsPanel">
                <div>‚õΩ <span id="fuelDisplay">100%</span></div>
                <div>‚ùÑÔ∏è <span id="coverageDisplay">0%</span></div>
                <div>‚ö° <span id="staminaDisplay">100%</span></div>
                <div>‚è±Ô∏è <span id="timerDisplay">5:00</span></div>
            </div>
        </div>
        
        <!-- Touch Controls -->
        <div id="touchControls" aria-hidden="true">
            <div class="touch-joystick" id="joystick">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
            <div class="touch-buttons">
                <button class="touch-btn" id="btnGroom" aria-label="Groom">GROOM</button>
                <button class="touch-btn" id="btnWinch" aria-label="Winch">WINCH</button>
                <button class="touch-btn" id="btnMenu" aria-label="Menu">‚ò∞</button>
            </div>
        </div>
        
        <!-- Dialogue Box -->
        <div id="dialogueBox" role="dialog" aria-labelledby="dialogueSpeaker">
            <div class="dialogue-speaker" id="dialogueSpeaker"></div>
            <div class="dialogue-text" id="dialogueText"></div>
            <div style="text-align: center; margin-top: 15px; color: #888; font-size: 12px;">
                <span data-i18n="pressContinue">Press Space or tap to continue</span>
            </div>
        </div>
        
        <!-- Main Menu -->
        <div class="menu-overlay" id="mainMenu">
            <h1 class="menu-title">üèîÔ∏è Les Aiguilles Blanches</h1>
            <p class="menu-subtitle" data-i18n="subtitle">Snow Groomer Simulation</p>
            <button class="menu-btn" id="btnStart" data-i18n="startGame">Start Game</button>
            <button class="menu-btn" id="btnContinue" data-i18n="continue" style="display:none;">Continue</button>
            <button class="menu-btn" id="btnHowToPlay" data-i18n="howToPlay">How to Play</button>
            <button class="menu-btn" id="btnSettings" data-i18n="settings">Settings</button>
            <button class="menu-btn" id="btnControls" data-i18n="controls">Controls</button>
        </div>
        
        <!-- How to Play -->
        <div class="menu-overlay hidden" id="howToPlayMenu">
            <div class="settings-panel" style="max-width: 600px;">
                <h2 data-i18n="howToPlay">How to Play</h2>
                
                <div class="settings-section">
                    <h3>üöú <span data-i18n="yourMission">Your Mission</span></h3>
                    <p data-i18n="missionText">You are a snow groomer operator at Les Aiguilles Blanches ski resort in Savoie. Your job is to prepare the pistes before the skiers arrive each morning.</p>
                </div>
                
                <div class="settings-section">
                    <h3>üéÆ <span data-i18n="controls">Controls</span></h3>
                    <p data-i18n="controlsText">Move with WASD or Arrow keys. Hold SPACE to activate the tiller and groom the snow. On steep slopes, use SHIFT to deploy the winch.</p>
                </div>
                
                <div class="settings-section">
                    <h3>‚õΩ <span data-i18n="resources">Resources</span></h3>
                    <p data-i18n="resourcesText">Watch your fuel and stamina! Refuel at the station (‚õΩ) and stop by Chez Marie for a tartiflette to restore your energy.</p>
                </div>
                
                <div class="settings-section">
                    <h3>üéØ <span data-i18n="objectives">Objectives</span></h3>
                    <p data-i18n="objectivesText">Groom enough snow to reach the coverage target before time runs out. Avoid obstacles like trees, rocks, and lift pylons!</p>
                </div>
                
                <div class="settings-section">
                    <h3>üßÄ <span data-i18n="savoyard">Savoyard Tips</span></h3>
                    <p data-i18n="savoyardText">Visit Chez Marie for local specialties: Tartiflette restores full energy, Fondue gives stamina regen, and Vin Chaud helps in storms!</p>
                </div>
                
                <button class="menu-btn" id="btnBackHowToPlay" data-i18n="back">Back</button>
            </div>
        </div>
        
        <!-- Settings Menu -->
        <div class="menu-overlay hidden" id="settingsMenu">
            <div class="settings-panel">
                <h2 data-i18n="settings">Settings</h2>
                
                <div class="settings-section">
                    <h3 data-i18n="language">Language</h3>
                    <div class="setting-row">
                        <label for="langSelect" data-i18n="selectLanguage">Select Language</label>
                        <select id="langSelect">
                            <option value="fr">Fran√ßais</option>
                            <option value="en">English</option>
                            <option value="de">Deutsch</option>
                            <option value="it">Italiano</option>
                            <option value="es">Espa√±ol</option>
                        </select>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3 data-i18n="accessibility">Accessibility</h3>
                    <div class="setting-row">
                        <label for="highContrast" data-i18n="highContrast">High Contrast Mode</label>
                        <input type="checkbox" id="highContrast">
                    </div>
                    <div class="setting-row">
                        <label for="colorblindMode" data-i18n="colorblindMode">Colorblind Mode</label>
                        <select id="colorblindMode">
                            <option value="none" data-i18n="none">None</option>
                            <option value="deuteranopia">Deuteranopia</option>
                            <option value="protanopia">Protanopia</option>
                            <option value="tritanopia">Tritanopia</option>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label for="reducedMotion" data-i18n="reducedMotion">Reduced Motion</label>
                        <input type="checkbox" id="reducedMotion">
                    </div>
                    <div class="setting-row">
                        <label for="uiScale" data-i18n="uiScale">UI Scale</label>
                        <select id="uiScale">
                            <option value="1">100%</option>
                            <option value="1.25">125%</option>
                            <option value="1.5">150%</option>
                            <option value="2">200%</option>
                        </select>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3 data-i18n="audio">Audio</h3>
                    <div class="setting-row">
                        <label for="musicVolume" data-i18n="music">Music</label>
                        <input type="range" id="musicVolume" min="0" max="100" value="70">
                    </div>
                    <div class="setting-row">
                        <label for="sfxVolume" data-i18n="sfx">Sound Effects</label>
                        <input type="range" id="sfxVolume" min="0" max="100" value="100">
                    </div>
                </div>
                
                <button class="menu-btn" id="btnBackSettings" data-i18n="back">Back</button>
            </div>
        </div>
        
        <!-- Controls Menu -->
        <div class="menu-overlay hidden" id="controlsMenu">
            <div class="settings-panel">
                <h2 data-i18n="controls">Controls</h2>
                
                <div class="settings-section">
                    <h3 data-i18n="keyboard">Keyboard</h3>
                    <div class="setting-row">
                        <label data-i18n="moveUp">Move Up</label>
                        <button class="menu-btn" style="min-width:100px" data-rebind="up">W / ‚Üë</button>
                    </div>
                    <div class="setting-row">
                        <label data-i18n="moveDown">Move Down</label>
                        <button class="menu-btn" style="min-width:100px" data-rebind="down">S / ‚Üì</button>
                    </div>
                    <div class="setting-row">
                        <label data-i18n="moveLeft">Move Left</label>
                        <button class="menu-btn" style="min-width:100px" data-rebind="left">A / ‚Üê</button>
                    </div>
                    <div class="setting-row">
                        <label data-i18n="moveRight">Move Right</label>
                        <button class="menu-btn" style="min-width:100px" data-rebind="right">D / ‚Üí</button>
                    </div>
                    <div class="setting-row">
                        <label data-i18n="groom">Groom</label>
                        <button class="menu-btn" style="min-width:100px" data-rebind="groom">Space</button>
                    </div>
                    <div class="setting-row">
                        <label data-i18n="winch">Winch</label>
                        <button class="menu-btn" style="min-width:100px" data-rebind="winch">Shift</button>
                    </div>
                </div>
                
                <p style="margin: 15px 0; color: #aaa; font-size: 14px;" data-i18n="gamepadSupport">
                    üéÆ Gamepad: D-pad/Stick to move, A to groom, B for winch
                </p>
                <p style="margin: 15px 0; color: #aaa; font-size: 14px;" data-i18n="touchSupport">
                    üì± Touch: Virtual joystick on left, action buttons on right
                </p>
                
                <button class="menu-btn" id="btnBackControls" data-i18n="back">Back</button>
            </div>
        </div>
        
        <!-- Pause Menu -->
        <div class="menu-overlay hidden" id="pauseMenu">
            <h2 data-i18n="paused">Paused</h2>
            <button class="menu-btn" id="btnResume" data-i18n="resume">Resume</button>
            <button class="menu-btn" id="btnPauseSettings" data-i18n="settings">Settings</button>
            <button class="menu-btn" id="btnQuit" data-i18n="quitToMenu">Quit to Menu</button>
        </div>
        
        <!-- Level Complete -->
        <div class="menu-overlay hidden" id="levelCompleteMenu">
            <div class="level-complete">
                <h2 data-i18n="levelComplete">Level Complete!</h2>
                <div class="stats">
                    <div>‚ùÑÔ∏è <span data-i18n="coverage">Coverage</span>: <span id="finalCoverage">95%</span></div>
                    <div>‚è±Ô∏è <span data-i18n="time">Time</span>: <span id="finalTime">3:42</span></div>
                    <div>‚≠ê <span data-i18n="rating">Rating</span>: <span id="finalRating">‚≠ê‚≠ê‚≠ê</span></div>
                </div>
                <button class="menu-btn" id="btnNextLevel" data-i18n="nextLevel">Next Level</button>
                <button class="menu-btn" id="btnReplay" data-i18n="replay">Replay</button>
            </div>
        </div>
        
        <!-- Level Failed -->
        <div class="menu-overlay hidden" id="levelFailedMenu">
            <div class="level-complete level-failed">
                <h2 data-i18n="levelFailed">Level Failed</h2>
                <p style="margin: 20px 0; color: #aaa;" data-i18n="tryAgainText">Don't give up! The mountain awaits.</p>
                <button class="menu-btn" id="btnTryAgain" data-i18n="tryAgain">Try Again</button>
                <button class="menu-btn" id="btnFailQuit" data-i18n="quitToMenu">Quit to Menu</button>
            </div>
        </div>
    </div>

    <script>
    // ============================================
    // LOCALIZATION SYSTEM
    // ============================================
    const TRANSLATIONS = {
        fr: {
            subtitle: "Simulation de Damage",
            startGame: "Commencer",
            continue: "Continuer",
            settings: "Param√®tres",
            controls: "Contr√¥les",
            language: "Langue",
            selectLanguage: "Choisir la langue",
            accessibility: "Accessibilit√©",
            highContrast: "Mode contraste √©lev√©",
            colorblindMode: "Mode daltonien",
            none: "Aucun",
            reducedMotion: "R√©duire les animations",
            uiScale: "√âchelle de l'interface",
            audio: "Audio",
            music: "Musique",
            sfx: "Effets sonores",
            back: "Retour",
            keyboard: "Clavier",
            moveUp: "Monter",
            moveDown: "Descendre",
            moveLeft: "Aller √† gauche",
            moveRight: "Aller √† droite",
            groom: "Damer",
            winch: "Treuil",
            gamepadSupport: "üéÆ Manette: D-pad/Stick pour bouger, A pour damer, B pour treuil",
            touchSupport: "üì± Tactile: Joystick virtuel √† gauche, boutons d'action √† droite",
            paused: "Pause",
            resume: "Reprendre",
            quitToMenu: "Retour au menu",
            levelComplete: "Niveau termin√© !",
            coverage: "Couverture",
            time: "Temps",
            rating: "Note",
            nextLevel: "Niveau suivant",
            replay: "Rejouer",
            pressContinue: "Appuyez sur Espace ou touchez pour continuer",
            level1Name: "Piste Verte - Les Marmottes",
            level1Task: "Damez la piste d√©butant",
            level2Name: "Piste Bleue - Le Chamois",
            level2Task: "Damez efficacement avant l'ouverture",
            level3Name: "Snowpark - Air Zone",
            level3Task: "Pr√©parez les modules de freestyle",
            level4Name: "Piste Rouge - L'Aigle",
            level4Task: "Damez le terrain pentu, g√©rez le carburant",
            level5Name: "Half-pipe - Le Tube",
            level5Task: "Entretenez le half-pipe pour la comp√©tition",
            level6Name: "Piste Noire - La Verticale",
            level6Task: "Op√©ration nocturne avec treuil",
            level7Name: "Zone Avalanche - Col Dangereux",
            level7Task: "Pr√©parez la zone √† haut risque",
            level8Name: "Temp√™te - R√©cup√©ration",
            level8Task: "D√©gagez les pistes apr√®s la temp√™te",
            jeanPierreIntro: "Bienvenue aux Aiguilles Blanches, petit ! Je suis Jean-Pierre, le chef dameur. Ce soir, tu vas apprendre les bases. Monte dans la dameuse et suis mes instructions.",
            marieWelcome: "H√©, le dameur ! Viens te r√©chauffer Chez Marie. Une bonne tartiflette, √ßa te remettra d'aplomb !",
            thierryWarning: "Attention, la zone avalanche est sensible aujourd'hui. Soyez prudent l√†-haut."
        },
        en: {
            subtitle: "Snow Groomer Simulation",
            startGame: "Start Game",
            continue: "Continue",
            settings: "Settings",
            controls: "Controls",
            language: "Language",
            selectLanguage: "Select Language",
            accessibility: "Accessibility",
            highContrast: "High Contrast Mode",
            colorblindMode: "Colorblind Mode",
            none: "None",
            reducedMotion: "Reduced Motion",
            uiScale: "UI Scale",
            audio: "Audio",
            music: "Music",
            sfx: "Sound Effects",
            back: "Back",
            keyboard: "Keyboard",
            moveUp: "Move Up",
            moveDown: "Move Down",
            moveLeft: "Move Left",
            moveRight: "Move Right",
            groom: "Groom",
            winch: "Winch",
            gamepadSupport: "üéÆ Gamepad: D-pad/Stick to move, A to groom, B for winch",
            touchSupport: "üì± Touch: Virtual joystick on left, action buttons on right",
            paused: "Paused",
            resume: "Resume",
            quitToMenu: "Quit to Menu",
            levelComplete: "Level Complete!",
            coverage: "Coverage",
            time: "Time",
            rating: "Rating",
            nextLevel: "Next Level",
            replay: "Replay",
            pressContinue: "Press Space or tap to continue",
            level1Name: "Green Piste - Les Marmottes",
            level1Task: "Groom the beginner slope",
            level2Name: "Blue Piste - Le Chamois",
            level2Task: "Groom efficiently before opening",
            level3Name: "Snowpark - Air Zone",
            level3Task: "Prepare freestyle features",
            level4Name: "Red Piste - L'Aigle",
            level4Task: "Groom steep terrain, manage fuel",
            level5Name: "Half-pipe - Le Tube",
            level5Task: "Maintain the half-pipe for competition",
            level6Name: "Black Piste - La Verticale",
            level6Task: "Night operation with winch",
            level7Name: "Avalanche Zone - Col Dangereux",
            level7Task: "Prepare the high-risk zone",
            level8Name: "Storm - Recovery",
            level8Task: "Clear pistes after the storm",
            jeanPierreIntro: "Welcome to Les Aiguilles Blanches, kid! I'm Jean-Pierre, head groomer. Tonight, you'll learn the basics. Get in the machine and follow my instructions.",
            marieWelcome: "Hey, groomer! Come warm up at Chez Marie. A good tartiflette will get you back on your feet!",
            thierryWarning: "Careful, the avalanche zone is sensitive today. Be cautious up there."
        },
        de: {
            subtitle: "Pistenraupe Simulation",
            startGame: "Spiel starten",
            continue: "Fortsetzen",
            settings: "Einstellungen",
            controls: "Steuerung",
            language: "Sprache",
            selectLanguage: "Sprache w√§hlen",
            accessibility: "Barrierefreiheit",
            highContrast: "Hoher Kontrast",
            colorblindMode: "Farbenblind-Modus",
            none: "Keine",
            reducedMotion: "Reduzierte Bewegung",
            uiScale: "UI-Gr√∂√üe",
            audio: "Audio",
            music: "Musik",
            sfx: "Soundeffekte",
            back: "Zur√ºck",
            keyboard: "Tastatur",
            moveUp: "Nach oben",
            moveDown: "Nach unten",
            moveLeft: "Nach links",
            moveRight: "Nach rechts",
            groom: "Pr√§parieren",
            winch: "Seilwinde",
            gamepadSupport: "üéÆ Gamepad: D-Pad/Stick zum Bewegen, A zum Pr√§parieren, B f√ºr Seilwinde",
            touchSupport: "üì± Touch: Virtueller Joystick links, Aktionstasten rechts",
            paused: "Pausiert",
            resume: "Fortsetzen",
            quitToMenu: "Zum Men√º",
            levelComplete: "Level geschafft!",
            coverage: "Abdeckung",
            time: "Zeit",
            rating: "Bewertung",
            nextLevel: "N√§chstes Level",
            replay: "Wiederholen",
            pressContinue: "Leertaste dr√ºcken oder tippen zum Fortfahren"
        },
        it: {
            subtitle: "Simulazione Gatto delle Nevi",
            startGame: "Inizia",
            continue: "Continua",
            settings: "Impostazioni",
            controls: "Controlli",
            language: "Lingua",
            selectLanguage: "Seleziona lingua",
            accessibility: "Accessibilit√†",
            highContrast: "Alto contrasto",
            colorblindMode: "Modalit√† daltonico",
            none: "Nessuno",
            reducedMotion: "Movimento ridotto",
            uiScale: "Scala UI",
            audio: "Audio",
            music: "Musica",
            sfx: "Effetti sonori",
            back: "Indietro",
            keyboard: "Tastiera",
            moveUp: "Su",
            moveDown: "Gi√π",
            moveLeft: "Sinistra",
            moveRight: "Destra",
            groom: "Battipista",
            winch: "Verricello",
            paused: "Pausa",
            resume: "Riprendi",
            quitToMenu: "Esci al menu",
            levelComplete: "Livello completato!",
            coverage: "Copertura",
            time: "Tempo",
            rating: "Valutazione",
            nextLevel: "Prossimo livello",
            replay: "Rigioca",
            pressContinue: "Premi Spazio o tocca per continuare"
        },
        es: {
            subtitle: "Simulaci√≥n de Pisapistas",
            startGame: "Empezar",
            continue: "Continuar",
            settings: "Ajustes",
            controls: "Controles",
            language: "Idioma",
            selectLanguage: "Seleccionar idioma",
            accessibility: "Accesibilidad",
            highContrast: "Alto contraste",
            colorblindMode: "Modo dalt√≥nico",
            none: "Ninguno",
            reducedMotion: "Movimiento reducido",
            uiScale: "Escala UI",
            audio: "Audio",
            music: "M√∫sica",
            sfx: "Efectos de sonido",
            back: "Volver",
            keyboard: "Teclado",
            moveUp: "Arriba",
            moveDown: "Abajo",
            moveLeft: "Izquierda",
            moveRight: "Derecha",
            groom: "Pisar",
            winch: "Cabrestante",
            paused: "Pausado",
            resume: "Reanudar",
            quitToMenu: "Salir al men√∫",
            levelComplete: "¬°Nivel completado!",
            coverage: "Cobertura",
            time: "Tiempo",
            rating: "Puntuaci√≥n",
            nextLevel: "Siguiente nivel",
            replay: "Repetir",
            pressContinue: "Pulsa Espacio o toca para continuar"
        }
    };

    let currentLang = 'fr';

    function setLanguage(lang) {
        currentLang = lang;
        localStorage.setItem('snowGroomer_lang', lang);
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            if (TRANSLATIONS[lang] && TRANSLATIONS[lang][key]) {
                el.textContent = TRANSLATIONS[lang][key];
            }
        });
    }

    function t(key) {
        return TRANSLATIONS[currentLang]?.[key] || TRANSLATIONS['en']?.[key] || key;
    }

    // ============================================
    // GAME CONFIGURATION
    // ============================================
    const CONFIG = {
        TILE_SIZE: 16,
        GROOMER_SPEED: 2,
        GROOMER_WIDTH: 32,
        GROOMER_HEIGHT: 48,
        FUEL_CONSUMPTION: 0.02,
        STAMINA_CONSUMPTION: 0.01,
        GROOM_WIDTH: 24
    };

    // ============================================
    // LEVELS DEFINITION
    // ============================================
    const LEVELS = [
        {
            id: 1,
            nameKey: 'level1Name',
            taskKey: 'level1Task',
            difficulty: 'green',
            timeLimit: 300,
            targetCoverage: 80,
            width: 40,
            height: 60,
            hasWinch: false,
            isNight: false,
            weather: 'clear',
            obstacles: ['trees'],
            introDialogue: 'jeanPierreIntro'
        },
        {
            id: 2,
            nameKey: 'level2Name',
            taskKey: 'level2Task',
            difficulty: 'blue',
            timeLimit: 240,
            targetCoverage: 85,
            width: 50,
            height: 70,
            hasWinch: false,
            isNight: false,
            weather: 'clear',
            obstacles: ['trees', 'rocks']
        },
        {
            id: 3,
            nameKey: 'level3Name',
            taskKey: 'level3Task',
            difficulty: 'park',
            timeLimit: 300,
            targetCoverage: 90,
            width: 45,
            height: 50,
            hasWinch: false,
            isNight: false,
            weather: 'clear',
            obstacles: ['jumps', 'rails'],
            specialFeatures: ['kickers', 'rails']
        },
        {
            id: 4,
            nameKey: 'level4Name',
            taskKey: 'level4Task',
            difficulty: 'red',
            timeLimit: 280,
            targetCoverage: 80,
            width: 35,
            height: 80,
            hasWinch: false,
            isNight: false,
            weather: 'clear',
            obstacles: ['trees', 'rocks', 'pylons'],
            steepSections: true
        },
        {
            id: 5,
            nameKey: 'level5Name',
            taskKey: 'level5Task',
            difficulty: 'park',
            timeLimit: 360,
            targetCoverage: 95,
            width: 20,
            height: 60,
            hasWinch: false,
            isNight: false,
            weather: 'clear',
            specialFeatures: ['halfpipe']
        },
        {
            id: 6,
            nameKey: 'level6Name',
            taskKey: 'level6Task',
            difficulty: 'black',
            timeLimit: 360,
            targetCoverage: 75,
            width: 30,
            height: 90,
            hasWinch: true,
            isNight: true,
            weather: 'clear',
            obstacles: ['trees', 'rocks', 'cliffs']
        },
        {
            id: 7,
            nameKey: 'level7Name',
            taskKey: 'level7Task',
            difficulty: 'black',
            timeLimit: 300,
            targetCoverage: 70,
            width: 40,
            height: 70,
            hasWinch: true,
            isNight: false,
            weather: 'light_snow',
            obstacles: ['avalanche_zones'],
            hazards: ['avalanche']
        },
        {
            id: 8,
            nameKey: 'level8Name',
            taskKey: 'level8Task',
            difficulty: 'red',
            timeLimit: 420,
            targetCoverage: 85,
            width: 60,
            height: 80,
            hasWinch: true,
            isNight: false,
            weather: 'storm',
            obstacles: ['trees', 'rocks', 'snow_drifts']
        }
    ];

    // ============================================
    // FOOD & DRINK ITEMS
    // ============================================
    const FOOD_ITEMS = {
        tartiflette: { stamina: 100, buff: 'coldResist', buffDuration: 120, icon: 'ü•î' },
        croziflette: { stamina: 50, buff: 'speed', buffDuration: 120, icon: 'üçù' },
        fondue: { stamina: 30, buff: 'staminaRegen', buffDuration: 180, icon: 'üßÄ' },
        genepi: { stamina: 20, buff: 'precision', buffDuration: 90, icon: 'ü•É' },
        vinChaud: { stamina: 40, buff: 'warmth', buffDuration: 150, icon: 'üç∑' },
        cafe: { stamina: 25, buff: null, buffDuration: 0, icon: '‚òï' }
    };

    // ============================================
    // INPUT SYSTEM (Unified)
    // ============================================
    class InputManager {
        constructor() {
            this.keys = {};
            this.gamepadIndex = null;
            this.touchState = { x: 0, y: 0, groom: false, winch: false };
            this.mouseState = { x: 0, y: 0, clicking: false };
            this.rebindingAction = null;
            
            // Key bindings (using physical key codes for layout independence)
            this.bindings = {
                up: ['KeyW', 'ArrowUp'],
                down: ['KeyS', 'ArrowDown'],
                left: ['KeyA', 'ArrowLeft'],
                right: ['KeyD', 'ArrowRight'],
                groom: ['Space'],
                winch: ['ShiftLeft', 'ShiftRight'],
                pause: ['Escape', 'KeyP']
            };
            
            // Load saved bindings
            this.loadBindings();
            
            this.setupKeyboard();
            this.setupGamepad();
            this.setupTouch();
            this.setupMouse();
            this.setupRebinding();
        }
        
        loadBindings() {
            const saved = localStorage.getItem('snowGroomer_bindings');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    Object.assign(this.bindings, parsed);
                } catch (e) {}
            }
        }
        
        saveBindings() {
            localStorage.setItem('snowGroomer_bindings', JSON.stringify(this.bindings));
        }
        
        setupRebinding() {
            document.querySelectorAll('[data-rebind]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (this.rebindingAction) return;
                    
                    const action = btn.getAttribute('data-rebind');
                    this.rebindingAction = action;
                    btn.textContent = '...';
                    btn.classList.add('rebinding');
                    
                    const handleKey = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        if (e.code === 'Escape') {
                            // Cancel rebinding
                            this.updateRebindButton(btn, action);
                            this.rebindingAction = null;
                            btn.classList.remove('rebinding');
                            document.removeEventListener('keydown', handleKey, true);
                            return;
                        }
                        
                        // Set new binding (keep arrow as fallback for movement)
                        if (['up', 'down', 'left', 'right'].includes(action)) {
                            this.bindings[action] = [e.code, this.bindings[action].find(k => k.startsWith('Arrow')) || e.code];
                        } else {
                            this.bindings[action] = [e.code];
                        }
                        
                        this.saveBindings();
                        this.updateRebindButton(btn, action);
                        this.rebindingAction = null;
                        btn.classList.remove('rebinding');
                        document.removeEventListener('keydown', handleKey, true);
                    };
                    
                    document.addEventListener('keydown', handleKey, true);
                });
            });
            
            // Update all buttons with current bindings
            document.querySelectorAll('[data-rebind]').forEach(btn => {
                const action = btn.getAttribute('data-rebind');
                this.updateRebindButton(btn, action);
            });
        }
        
        updateRebindButton(btn, action) {
            const keys = this.bindings[action] || [];
            const displayNames = keys.map(k => this.keyCodeToDisplay(k));
            btn.textContent = displayNames.join(' / ') || '---';
        }
        
        keyCodeToDisplay(code) {
            const map = {
                'KeyW': 'W', 'KeyA': 'A', 'KeyS': 'S', 'KeyD': 'D',
                'KeyZ': 'Z', 'KeyQ': 'Q',
                'ArrowUp': '‚Üë', 'ArrowDown': '‚Üì', 'ArrowLeft': '‚Üê', 'ArrowRight': '‚Üí',
                'Space': 'Space', 'ShiftLeft': 'Shift', 'ShiftRight': 'Shift',
                'Escape': 'Esc', 'KeyP': 'P',
                'Enter': 'Enter', 'Backspace': 'Backspace',
                'ControlLeft': 'Ctrl', 'ControlRight': 'Ctrl',
                'AltLeft': 'Alt', 'AltRight': 'Alt'
            };
            return map[code] || code.replace('Key', '').replace('Digit', '');
        }
        
        setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                this.keys[e.code] = true;
                if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                    e.preventDefault();
                }
            });
            document.addEventListener('keyup', (e) => {
                this.keys[e.code] = false;
            });
        }
        
        setupGamepad() {
            window.addEventListener('gamepadconnected', (e) => {
                this.gamepadIndex = e.gamepad.index;
                announce(t('gamepadConnected') || 'Gamepad connected');
            });
            window.addEventListener('gamepaddisconnected', () => {
                this.gamepadIndex = null;
            });
        }
        
        setupTouch() {
            const joystick = document.getElementById('joystick');
            const knob = document.getElementById('joystickKnob');
            const btnGroom = document.getElementById('btnGroom');
            const btnWinch = document.getElementById('btnWinch');
            
            let joystickCenter = { x: 0, y: 0 };
            let joystickActive = false;
            
            const updateJoystickCenter = () => {
                const rect = joystick.getBoundingClientRect();
                joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            };
            
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                updateJoystickCenter();
            });
            
            joystick.addEventListener('touchmove', (e) => {
                if (!joystickActive) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - joystickCenter.x;
                const dy = touch.clientY - joystickCenter.y;
                const maxDist = 35;
                const dist = Math.min(Math.sqrt(dx * dx + dy * dy), maxDist);
                const angle = Math.atan2(dy, dx);
                
                const knobX = Math.cos(angle) * dist;
                const knobY = Math.sin(angle) * dist;
                knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
                
                this.touchState.x = knobX / maxDist;
                this.touchState.y = knobY / maxDist;
            });
            
            const resetJoystick = () => {
                joystickActive = false;
                knob.style.transform = 'translate(-50%, -50%)';
                this.touchState.x = 0;
                this.touchState.y = 0;
            };
            
            joystick.addEventListener('touchend', resetJoystick);
            joystick.addEventListener('touchcancel', resetJoystick);
            
            // Action buttons
            btnGroom.addEventListener('touchstart', (e) => { e.preventDefault(); this.touchState.groom = true; btnGroom.classList.add('active'); });
            btnGroom.addEventListener('touchend', () => { this.touchState.groom = false; btnGroom.classList.remove('active'); });
            btnWinch.addEventListener('touchstart', (e) => { e.preventDefault(); this.touchState.winch = true; btnWinch.classList.add('active'); });
            btnWinch.addEventListener('touchend', () => { this.touchState.winch = false; btnWinch.classList.remove('active'); });
        }
        
        setupMouse() {
            const canvas = document.getElementById('gameCanvas');
            canvas.addEventListener('mousedown', (e) => {
                this.mouseState.clicking = true;
                this.mouseState.x = e.clientX;
                this.mouseState.y = e.clientY;
            });
            canvas.addEventListener('mouseup', () => {
                this.mouseState.clicking = false;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (this.mouseState.clicking) {
                    this.mouseState.x = e.clientX;
                    this.mouseState.y = e.clientY;
                }
            });
        }
        
        isPressed(action) {
            // Check keyboard
            for (const code of this.bindings[action] || []) {
                if (this.keys[code]) return true;
            }
            
            // Check gamepad
            if (this.gamepadIndex !== null) {
                const gp = navigator.getGamepads()[this.gamepadIndex];
                if (gp) {
                    switch (action) {
                        case 'up': return gp.buttons[12]?.pressed || gp.axes[1] < -0.5;
                        case 'down': return gp.buttons[13]?.pressed || gp.axes[1] > 0.5;
                        case 'left': return gp.buttons[14]?.pressed || gp.axes[0] < -0.5;
                        case 'right': return gp.buttons[15]?.pressed || gp.axes[0] > 0.5;
                        case 'groom': return gp.buttons[0]?.pressed;
                        case 'winch': return gp.buttons[1]?.pressed;
                        case 'pause': return gp.buttons[9]?.pressed;
                    }
                }
            }
            
            // Check touch
            if (action === 'groom') return this.touchState.groom;
            if (action === 'winch') return this.touchState.winch;
            
            return false;
        }
        
        getMovement() {
            let dx = 0, dy = 0;
            
            // Keyboard / Gamepad
            if (this.isPressed('left')) dx -= 1;
            if (this.isPressed('right')) dx += 1;
            if (this.isPressed('up')) dy -= 1;
            if (this.isPressed('down')) dy += 1;
            
            // Touch joystick
            if (Math.abs(this.touchState.x) > 0.1 || Math.abs(this.touchState.y) > 0.1) {
                dx = this.touchState.x;
                dy = this.touchState.y;
            }
            
            // Normalize
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len > 1) {
                dx /= len;
                dy /= len;
            }
            
            return { dx, dy };
        }
    }

    // ============================================
    // ACCESSIBILITY HELPERS
    // ============================================
    function announce(message) {
        const el = document.getElementById('srAnnounce');
        el.textContent = message;
    }

    // ============================================
    // GAME STATE
    // ============================================
    const gameState = {
        currentLevel: 0,
        isPlaying: false,
        isPaused: false,
        showingDialogue: false,
        
        // Player
        groomer: {
            x: 0,
            y: 0,
            angle: 0,
            fuel: 100,
            stamina: 100,
            isGrooming: false,
            isUsingWinch: false,
            buffs: {}
        },
        
        // Level
        snowGrid: [],
        obstacles: [],
        coverage: 0,
        timeRemaining: 0,
        
        // Settings
        settings: {
            highContrast: false,
            colorblindMode: 'none',
            reducedMotion: false,
            uiScale: 1,
            musicVolume: 70,
            sfxVolume: 100
        }
    };

    // ============================================
    // RENDERING
    // ============================================
    class Renderer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.resize();
            window.addEventListener('resize', () => this.resize());
        }
        
        resize() {
            const container = document.getElementById('gameContainer');
            this.canvas.width = container.clientWidth;
            this.canvas.height = container.clientHeight;
            this.ctx.imageSmoothingEnabled = false;
        }
        
        clear() {
            // Sky gradient (day/night)
            const level = LEVELS[gameState.currentLevel];
            const isNight = level?.isNight;
            
            const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
            if (isNight) {
                gradient.addColorStop(0, '#0a1628');
                gradient.addColorStop(0.5, '#1a2a4a');
                gradient.addColorStop(1, '#2a3a5a');
            } else {
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.3, '#B0E0E6');
                gradient.addColorStop(1, '#E8F4F8');
            }
            
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
        
        drawMountains() {
            const level = LEVELS[gameState.currentLevel];
            const isNight = level?.isNight;
            
            // Background mountains
            this.ctx.fillStyle = isNight ? '#3a4a6a' : '#94A3B8';
            this.ctx.beginPath();
            this.ctx.moveTo(0, 150);
            this.ctx.lineTo(100, 80);
            this.ctx.lineTo(200, 120);
            this.ctx.lineTo(350, 50);
            this.ctx.lineTo(500, 100);
            this.ctx.lineTo(650, 60);
            this.ctx.lineTo(800, 130);
            this.ctx.lineTo(this.canvas.width, 100);
            this.ctx.lineTo(this.canvas.width, 200);
            this.ctx.lineTo(0, 200);
            this.ctx.fill();
            
            // Snow caps
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.beginPath();
            this.ctx.moveTo(340, 50);
            this.ctx.lineTo(350, 50);
            this.ctx.lineTo(360, 70);
            this.ctx.lineTo(340, 70);
            this.ctx.fill();
        }
        
        drawSnowGrid(grid, offsetX, offsetY) {
            if (!grid || !grid.length) return;
            
            const settings = gameState.settings;
            const tileSize = CONFIG.TILE_SIZE;
            
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    const cell = grid[y][x];
                    const screenX = x * tileSize + offsetX;
                    const screenY = y * tileSize + offsetY + 180;
                    
                    // Skip if off screen
                    if (screenX < -tileSize || screenX > this.canvas.width ||
                        screenY < -tileSize || screenY > this.canvas.height) continue;
                    
                    // Snow state colors
                    let color;
                    if (cell.groomed) {
                        color = settings.highContrast ? '#FFFFFF' : '#F0F8FF';
                        // Corduroy pattern
                        if (!settings.reducedMotion) {
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(screenX, screenY, tileSize, tileSize);
                            this.ctx.strokeStyle = settings.highContrast ? '#CCCCCC' : '#E0E8F0';
                            this.ctx.lineWidth = 1;
                            for (let i = 2; i < tileSize; i += 4) {
                                this.ctx.beginPath();
                                this.ctx.moveTo(screenX, screenY + i);
                                this.ctx.lineTo(screenX + tileSize, screenY + i);
                                this.ctx.stroke();
                            }
                            continue;
                        }
                    } else if (cell.type === 'powder') {
                        color = settings.highContrast ? '#E8E8E8' : '#E8F4F8';
                    } else if (cell.type === 'ice') {
                        color = settings.highContrast ? '#AADDFF' : '#B8E0F0';
                    } else if (cell.type === 'deep') {
                        color = settings.highContrast ? '#CCCCCC' : '#D0E0E8';
                    } else {
                        color = '#E0ECF0';
                    }
                    
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(screenX, screenY, tileSize, tileSize);
                }
            }
        }
        
        drawObstacles(obstacles, offsetX, offsetY) {
            const settings = gameState.settings;
            
            for (const obs of obstacles) {
                const screenX = obs.x + offsetX;
                const screenY = obs.y + offsetY + 180;
                
                if (screenX < -50 || screenX > this.canvas.width + 50 ||
                    screenY < -50 || screenY > this.canvas.height + 50) continue;
                
                this.ctx.save();
                
                switch (obs.type) {
                    case 'tree':
                        // SkiFree style tree
                        this.ctx.fillStyle = settings.highContrast ? '#004400' : '#228B22';
                        this.ctx.beginPath();
                        this.ctx.moveTo(screenX, screenY - 30);
                        this.ctx.lineTo(screenX - 15, screenY);
                        this.ctx.lineTo(screenX + 15, screenY);
                        this.ctx.fill();
                        
                        this.ctx.fillStyle = '#8B4513';
                        this.ctx.fillRect(screenX - 3, screenY, 6, 10);
                        break;
                        
                    case 'rock':
                        this.ctx.fillStyle = settings.highContrast ? '#333333' : '#696969';
                        this.ctx.beginPath();
                        this.ctx.ellipse(screenX, screenY, 12, 8, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'pylon':
                        this.ctx.fillStyle = settings.highContrast ? '#000000' : '#444444';
                        this.ctx.fillRect(screenX - 4, screenY - 40, 8, 50);
                        this.ctx.fillStyle = '#FF0000';
                        this.ctx.fillRect(screenX - 15, screenY - 45, 30, 8);
                        break;
                        
                    case 'restaurant':
                        // Chez Marie
                        this.ctx.fillStyle = '#8B4513';
                        this.ctx.fillRect(screenX - 25, screenY - 20, 50, 30);
                        this.ctx.fillStyle = '#A52A2A';
                        this.ctx.beginPath();
                        this.ctx.moveTo(screenX - 30, screenY - 20);
                        this.ctx.lineTo(screenX, screenY - 40);
                        this.ctx.lineTo(screenX + 30, screenY - 20);
                        this.ctx.fill();
                        this.ctx.fillStyle = '#FFFF00';
                        this.ctx.fillRect(screenX - 8, screenY - 10, 16, 12);
                        break;
                        
                    case 'fuel':
                        this.ctx.fillStyle = '#FF4444';
                        this.ctx.fillRect(screenX - 15, screenY - 20, 30, 25);
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.font = '12px monospace';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('‚õΩ', screenX, screenY - 5);
                        break;
                }
                
                this.ctx.restore();
            }
        }
        
        drawGroomer(groomer, offsetX, offsetY) {
            const settings = gameState.settings;
            const screenX = groomer.x + offsetX;
            const screenY = groomer.y + offsetY + 180;
            
            this.ctx.save();
            this.ctx.translate(screenX, screenY);
            this.ctx.rotate(groomer.angle);
            
            // PistenBully-style groomer
            // Tracks
            this.ctx.fillStyle = settings.highContrast ? '#000000' : '#333333';
            this.ctx.fillRect(-18, -20, 8, 40);
            this.ctx.fillRect(10, -20, 8, 40);
            
            // Body
            this.ctx.fillStyle = settings.highContrast ? '#FF0000' : '#CC2200';
            this.ctx.fillRect(-14, -15, 28, 25);
            
            // Cabin
            this.ctx.fillStyle = settings.highContrast ? '#0000FF' : '#1E90FF';
            this.ctx.fillRect(-10, -10, 20, 15);
            
            // Window
            this.ctx.fillStyle = '#87CEEB';
            this.ctx.fillRect(-7, -7, 14, 8);
            
            // Tiller (rear)
            if (groomer.isGrooming) {
                this.ctx.fillStyle = settings.highContrast ? '#FFFF00' : '#FFD700';
            } else {
                this.ctx.fillStyle = '#888888';
            }
            this.ctx.fillRect(-16, 18, 32, 8);
            
            // Blade (front)
            this.ctx.fillStyle = '#666666';
            this.ctx.fillRect(-18, -24, 36, 4);
            
            // Headlights (if night)
            const level = LEVELS[gameState.currentLevel];
            if (level?.isNight) {
                this.ctx.fillStyle = '#FFFF00';
                this.ctx.beginPath();
                this.ctx.arc(-8, -22, 3, 0, Math.PI * 2);
                this.ctx.arc(8, -22, 3, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            this.ctx.restore();
            
            // Winch cable (if using)
            if (groomer.isUsingWinch) {
                this.ctx.strokeStyle = '#FFD700';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(screenX, screenY);
                this.ctx.lineTo(screenX, screenY - 200);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
        }
        
        drawWeatherEffects() {
            const level = LEVELS[gameState.currentLevel];
            if (!level || gameState.settings.reducedMotion) return;
            
            if (level.weather === 'light_snow' || level.weather === 'storm') {
                const intensity = level.weather === 'storm' ? 200 : 50;
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                
                for (let i = 0; i < intensity; i++) {
                    const x = (Math.random() * this.canvas.width + Date.now() * 0.1) % this.canvas.width;
                    const y = (Math.random() * this.canvas.height + Date.now() * 0.2) % this.canvas.height;
                    const size = level.weather === 'storm' ? 3 : 2;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
        
        drawNightOverlay() {
            const level = LEVELS[gameState.currentLevel];
            if (!level?.isNight) return;
            
            // Create spotlight effect around groomer
            const groomer = gameState.groomer;
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            
            const gradient = this.ctx.createRadialGradient(
                centerX, centerY, 50,
                centerX, centerY, 200
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.7)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
        
        applyColorblindFilter() {
            const mode = gameState.settings.colorblindMode;
            if (mode === 'none') return;
            
            // Apply CSS filter
            switch (mode) {
                case 'deuteranopia':
                    this.canvas.style.filter = 'url(#deuteranopia)';
                    break;
                case 'protanopia':
                    this.canvas.style.filter = 'url(#protanopia)';
                    break;
                case 'tritanopia':
                    this.canvas.style.filter = 'url(#tritanopia)';
                    break;
                default:
                    this.canvas.style.filter = 'none';
            }
        }
        
        render() {
            this.clear();
            this.drawMountains();
            
            // Calculate camera offset (center on groomer)
            const offsetX = this.canvas.width / 2 - gameState.groomer.x;
            const offsetY = this.canvas.height / 2 - gameState.groomer.y;
            
            this.drawSnowGrid(gameState.snowGrid, offsetX, offsetY);
            this.drawObstacles(gameState.obstacles, offsetX, offsetY);
            this.drawGroomer(gameState.groomer, offsetX, offsetY);
            this.drawWeatherEffects();
            this.drawNightOverlay();
        }
    }

    // ============================================
    // GAME LOGIC
    // ============================================
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.renderer = new Renderer(this.canvas);
            this.input = new InputManager();
            this.lastTime = 0;
            
            this.loadSettings();
            this.setupMenus();
            this.loop = this.loop.bind(this);
        }
        
        loadSettings() {
            const saved = localStorage.getItem('snowGroomer_settings');
            if (saved) {
                Object.assign(gameState.settings, JSON.parse(saved));
            }
            
            const savedLang = localStorage.getItem('snowGroomer_lang');
            if (savedLang) {
                currentLang = savedLang;
                document.getElementById('langSelect').value = savedLang;
            }
            
            this.applySettings();
        }
        
        saveSettings() {
            localStorage.setItem('snowGroomer_settings', JSON.stringify(gameState.settings));
        }
        
        applySettings() {
            const s = gameState.settings;
            
            // High contrast
            document.querySelectorAll('.hud-panel').forEach(el => {
                el.classList.toggle('high-contrast', s.highContrast);
            });
            
            // UI Scale
            document.getElementById('hud').style.transform = `scale(${s.uiScale})`;
            document.getElementById('hud').style.transformOrigin = 'top left';
            
            // Update UI elements
            document.getElementById('highContrast').checked = s.highContrast;
            document.getElementById('colorblindMode').value = s.colorblindMode;
            document.getElementById('reducedMotion').checked = s.reducedMotion;
            document.getElementById('uiScale').value = s.uiScale;
            document.getElementById('musicVolume').value = s.musicVolume;
            document.getElementById('sfxVolume').value = s.sfxVolume;
            
            setLanguage(currentLang);
        }
        
        setupMenus() {
            // Main menu buttons
            document.getElementById('btnStart').addEventListener('click', () => this.startGame());
            document.getElementById('btnSettings').addEventListener('click', () => this.showMenu('settingsMenu'));
            document.getElementById('btnControls').addEventListener('click', () => this.showMenu('controlsMenu'));
            document.getElementById('btnMenu').addEventListener('click', () => this.togglePause());
            
            // Settings
            document.getElementById('btnBackSettings').addEventListener('click', () => this.showMenu('mainMenu'));
            document.getElementById('btnBackControls').addEventListener('click', () => this.showMenu('mainMenu'));
            
            document.getElementById('langSelect').addEventListener('change', (e) => {
                setLanguage(e.target.value);
            });
            
            document.getElementById('highContrast').addEventListener('change', (e) => {
                gameState.settings.highContrast = e.target.checked;
                this.applySettings();
                this.saveSettings();
            });
            
            document.getElementById('colorblindMode').addEventListener('change', (e) => {
                gameState.settings.colorblindMode = e.target.value;
                this.renderer.applyColorblindFilter();
                this.saveSettings();
            });
            
            document.getElementById('reducedMotion').addEventListener('change', (e) => {
                gameState.settings.reducedMotion = e.target.checked;
                this.saveSettings();
            });
            
            document.getElementById('uiScale').addEventListener('change', (e) => {
                gameState.settings.uiScale = parseFloat(e.target.value);
                this.applySettings();
                this.saveSettings();
            });
            
            // Pause menu
            document.getElementById('btnResume').addEventListener('click', () => this.togglePause());
            document.getElementById('btnPauseSettings').addEventListener('click', () => this.showMenu('settingsMenu'));
            document.getElementById('btnQuit').addEventListener('click', () => {
                gameState.isPlaying = false;
                this.showMenu('mainMenu');
            });
            
            // Level complete
            document.getElementById('btnNextLevel').addEventListener('click', () => this.nextLevel());
            document.getElementById('btnReplay').addEventListener('click', () => this.startLevel(gameState.currentLevel));
            
            // Dialogue
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && gameState.showingDialogue) {
                    this.hideDialogue();
                }
            });
            document.getElementById('dialogueBox').addEventListener('click', () => {
                if (gameState.showingDialogue) this.hideDialogue();
            });
            
            // Pause on Escape
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Escape' && gameState.isPlaying) {
                    this.togglePause();
                }
            });
        }
        
        showMenu(menuId) {
            document.querySelectorAll('.menu-overlay').forEach(m => m.classList.add('hidden'));
            document.getElementById(menuId).classList.remove('hidden');
        }
        
        hideAllMenus() {
            document.querySelectorAll('.menu-overlay').forEach(m => m.classList.add('hidden'));
        }
        
        showDialogue(speakerKey, textKey) {
            const speaker = {
                'jeanPierreIntro': 'Jean-Pierre',
                'marieWelcome': 'Marie',
                'thierryWarning': 'Thierry'
            }[speakerKey] || speakerKey;
            
            document.getElementById('dialogueSpeaker').textContent = speaker;
            document.getElementById('dialogueText').textContent = t(textKey || speakerKey);
            document.getElementById('dialogueBox').classList.add('visible');
            gameState.showingDialogue = true;
            announce(speaker + ': ' + t(textKey || speakerKey));
        }
        
        hideDialogue() {
            document.getElementById('dialogueBox').classList.remove('visible');
            gameState.showingDialogue = false;
        }
        
        generateLevel(levelIndex) {
            const level = LEVELS[levelIndex];
            const grid = [];
            
            for (let y = 0; y < level.height; y++) {
                const row = [];
                for (let x = 0; x < level.width; x++) {
                    // Determine snow type based on level difficulty
                    let type = 'powder';
                    if (level.weather === 'storm') {
                        type = Math.random() < 0.4 ? 'deep' : 'powder';
                    } else if (level.difficulty === 'black' && Math.random() < 0.2) {
                        type = 'ice';
                    }
                    
                    row.push({
                        type,
                        groomed: false,
                        groomQuality: 0
                    });
                }
                grid.push(row);
            }
            
            return grid;
        }
        
        generateObstacles(levelIndex) {
            const level = LEVELS[levelIndex];
            const obstacles = [];
            const obstacleCount = Math.floor(level.width * level.height / 50);
            
            for (let i = 0; i < obstacleCount; i++) {
                const types = level.obstacles || ['trees'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                obstacles.push({
                    type,
                    x: Math.random() * level.width * CONFIG.TILE_SIZE,
                    y: Math.random() * level.height * CONFIG.TILE_SIZE,
                    width: 30,
                    height: 30
                });
            }
            
            // Add restaurant
            obstacles.push({
                type: 'restaurant',
                x: level.width * CONFIG.TILE_SIZE / 2,
                y: 50,
                width: 60,
                height: 40,
                isInteractive: true,
                interactionType: 'food'
            });
            
            // Add fuel station
            obstacles.push({
                type: 'fuel',
                x: 100,
                y: level.height * CONFIG.TILE_SIZE - 100,
                width: 40,
                height: 30,
                isInteractive: true,
                interactionType: 'fuel'
            });
            
            return obstacles;
        }
        
        startGame() {
            gameState.currentLevel = 0;
            this.startLevel(0);
        }
        
        startLevel(levelIndex) {
            const level = LEVELS[levelIndex];
            gameState.currentLevel = levelIndex;
            gameState.isPlaying = true;
            gameState.isPaused = false;
            
            // Reset groomer
            gameState.groomer = {
                x: level.width * CONFIG.TILE_SIZE / 2,
                y: level.height * CONFIG.TILE_SIZE - 100,
                angle: 0,
                fuel: 100,
                stamina: 100,
                isGrooming: false,
                isUsingWinch: false,
                buffs: {}
            };
            
            // Generate level
            gameState.snowGrid = this.generateLevel(levelIndex);
            gameState.obstacles = this.generateObstacles(levelIndex);
            gameState.coverage = 0;
            gameState.timeRemaining = level.timeLimit;
            
            // Update UI
            document.getElementById('levelName').textContent = t(level.nameKey);
            document.getElementById('levelTask').textContent = t(level.taskKey);
            
            this.hideAllMenus();
            
            // Show intro dialogue if exists
            if (level.introDialogue) {
                setTimeout(() => this.showDialogue(level.introDialogue, level.introDialogue), 500);
            }
            
            announce(t('levelStart') || 'Level ' + (levelIndex + 1) + ' started');
            
            requestAnimationFrame(this.loop);
        }
        
        nextLevel() {
            if (gameState.currentLevel < LEVELS.length - 1) {
                this.startLevel(gameState.currentLevel + 1);
            } else {
                // Game complete!
                announce(t('gameComplete') || 'Congratulations! You completed all levels!');
                this.showMenu('mainMenu');
            }
        }
        
        togglePause() {
            if (!gameState.isPlaying) return;
            
            gameState.isPaused = !gameState.isPaused;
            if (gameState.isPaused) {
                this.showMenu('pauseMenu');
            } else {
                this.hideAllMenus();
                requestAnimationFrame(this.loop);
            }
        }
        
        update(dt) {
            if (!gameState.isPlaying || gameState.isPaused || gameState.showingDialogue) return;
            
            const groomer = gameState.groomer;
            const level = LEVELS[gameState.currentLevel];
            
            // Get input
            const movement = this.input.getMovement();
            groomer.isGrooming = this.input.isPressed('groom');
            groomer.isUsingWinch = level.hasWinch && this.input.isPressed('winch');
            
            // Calculate speed
            let speed = CONFIG.GROOMER_SPEED;
            if (groomer.buffs.speed) speed *= 1.5;
            if (groomer.isUsingWinch) speed *= 0.5;
            
            // Move groomer
            if (movement.dx !== 0 || movement.dy !== 0) {
                groomer.x += movement.dx * speed;
                groomer.y += movement.dy * speed;
                groomer.angle = Math.atan2(movement.dy, movement.dx) + Math.PI / 2;
                
                // Consume fuel
                groomer.fuel -= CONFIG.FUEL_CONSUMPTION * dt;
                groomer.stamina -= CONFIG.STAMINA_CONSUMPTION * dt;
            }
            
            // Bounds
            const maxX = level.width * CONFIG.TILE_SIZE;
            const maxY = level.height * CONFIG.TILE_SIZE;
            groomer.x = Math.max(20, Math.min(maxX - 20, groomer.x));
            groomer.y = Math.max(20, Math.min(maxY - 20, groomer.y));
            
            // Grooming
            if (groomer.isGrooming && groomer.fuel > 0) {
                this.groomSnow(groomer.x, groomer.y);
            }
            
            // Check interactions
            this.checkInteractions();
            
            // Update timers
            gameState.timeRemaining -= dt;
            
            // Update coverage
            this.calculateCoverage();
            
            // Update HUD
            this.updateHUD();
            
            // Check win/lose conditions
            this.checkEndConditions();
            
            // Buff timers
            for (const buff in groomer.buffs) {
                groomer.buffs[buff] -= dt;
                if (groomer.buffs[buff] <= 0) {
                    delete groomer.buffs[buff];
                }
            }
        }
        
        groomSnow(x, y) {
            const grid = gameState.snowGrid;
            const tileSize = CONFIG.TILE_SIZE;
            const groomRadius = CONFIG.GROOM_WIDTH / 2;
            
            const startX = Math.floor((x - groomRadius) / tileSize);
            const endX = Math.ceil((x + groomRadius) / tileSize);
            const startY = Math.floor((y - groomRadius) / tileSize);
            const endY = Math.ceil((y + groomRadius) / tileSize);
            
            for (let ty = startY; ty <= endY; ty++) {
                for (let tx = startX; tx <= endX; tx++) {
                    if (ty >= 0 && ty < grid.length && tx >= 0 && tx < grid[0].length) {
                        grid[ty][tx].groomed = true;
                        grid[ty][tx].groomQuality = 100;
                    }
                }
            }
        }
        
        checkInteractions() {
            const groomer = gameState.groomer;
            
            for (const obs of gameState.obstacles) {
                if (!obs.isInteractive) continue;
                
                const dist = Math.hypot(groomer.x - obs.x, groomer.y - obs.y);
                if (dist < 50) {
                    if (obs.interactionType === 'fuel') {
                        groomer.fuel = Math.min(100, groomer.fuel + 0.5);
                    } else if (obs.interactionType === 'food' && this.input.isPressed('groom')) {
                        // Simple: restore stamina at restaurant
                        groomer.stamina = 100;
                        if (!groomer.buffs.staminaRegen) {
                            groomer.buffs.staminaRegen = 60;
                            announce(t('marieWelcome'));
                        }
                    }
                }
            }
        }
        
        calculateCoverage() {
            const grid = gameState.snowGrid;
            let groomed = 0;
            let total = 0;
            
            for (const row of grid) {
                for (const cell of row) {
                    total++;
                    if (cell.groomed) groomed++;
                }
            }
            
            gameState.coverage = Math.round((groomed / total) * 100);
        }
        
        updateHUD() {
            const groomer = gameState.groomer;
            document.getElementById('fuelDisplay').textContent = Math.round(groomer.fuel) + '%';
            document.getElementById('staminaDisplay').textContent = Math.round(groomer.stamina) + '%';
            document.getElementById('coverageDisplay').textContent = gameState.coverage + '%';
            
            const mins = Math.floor(gameState.timeRemaining / 60);
            const secs = Math.floor(gameState.timeRemaining % 60);
            document.getElementById('timerDisplay').textContent = 
                mins + ':' + secs.toString().padStart(2, '0');
        }
        
        checkEndConditions() {
            const level = LEVELS[gameState.currentLevel];
            
            // Win
            if (gameState.coverage >= level.targetCoverage) {
                this.levelComplete();
            }
            
            // Lose
            if (gameState.timeRemaining <= 0 || gameState.groomer.fuel <= 0) {
                this.levelFailed();
            }
        }
        
        levelComplete() {
            gameState.isPlaying = false;
            
            const level = LEVELS[gameState.currentLevel];
            const timeUsed = level.timeLimit - gameState.timeRemaining;
            const mins = Math.floor(timeUsed / 60);
            const secs = Math.floor(timeUsed % 60);
            
            // Calculate rating
            let stars = 1;
            if (gameState.coverage >= 90) stars++;
            if (timeUsed < level.timeLimit * 0.7) stars++;
            
            document.getElementById('finalCoverage').textContent = gameState.coverage + '%';
            document.getElementById('finalTime').textContent = mins + ':' + secs.toString().padStart(2, '0');
            document.getElementById('finalRating').textContent = '‚≠ê'.repeat(stars);
            
            this.showMenu('levelCompleteMenu');
            announce(t('levelComplete') + ' ' + stars + ' stars');
        }
        
        levelFailed() {
            gameState.isPlaying = false;
            announce(t('levelFailed') || 'Level failed. Try again!');
            // For now, just restart level
            setTimeout(() => this.startLevel(gameState.currentLevel), 2000);
        }
        
        loop(timestamp) {
            const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1);
            this.lastTime = timestamp;
            
            this.update(dt);
            this.renderer.render();
            
            if (gameState.isPlaying && !gameState.isPaused) {
                requestAnimationFrame(this.loop);
            }
        }
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    window.addEventListener('load', () => {
        const game = new Game();
        
        // Initial render
        game.renderer.render();
        
        // Handle visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState.isPlaying) {
                game.togglePause();
            }
        });
    });
    </script>
    
    <!-- SVG Filters for Colorblind Modes -->
    <svg style="display: none;">
        <defs>
            <filter id="deuteranopia">
                <feColorMatrix type="matrix" values="0.625 0.375 0 0 0  0.7 0.3 0 0 0  0 0.3 0.7 0 0  0 0 0 1 0"/>
            </filter>
            <filter id="protanopia">
                <feColorMatrix type="matrix" values="0.567 0.433 0 0 0  0.558 0.442 0 0 0  0 0.242 0.758 0 0  0 0 0 1 0"/>
            </filter>
            <filter id="tritanopia">
                <feColorMatrix type="matrix" values="0.95 0.05 0 0 0  0 0.433 0.567 0 0  0 0.475 0.525 0 0  0 0 0 1 0"/>
            </filter>
        </defs>
    </svg>
</body>
</html>
