<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Les Aiguilles Blanches - Test Suite</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #fff;
            padding: 20px;
        }
        h1 { margin-bottom: 20px; }
        .test-suite {
            background: #2a2a4e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .test-suite h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #87CEEB;
        }
        .test {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .test.pass { background: #1a4a1a; }
        .test.fail { background: #4a1a1a; }
        .test.pending { background: #4a4a1a; }
        .test-name { flex: 1; }
        .test-status { font-weight: bold; margin-left: 10px; }
        .pass .test-status { color: #4CAF50; }
        .fail .test-status { color: #f44336; }
        .pending .test-status { color: #ffeb3b; }
        .summary {
            margin-top: 20px;
            padding: 15px;
            background: #2a2a4e;
            border-radius: 8px;
            font-size: 18px;
        }
        .error-details {
            font-size: 12px;
            color: #ff8888;
            margin-top: 5px;
            white-space: pre-wrap;
        }
        #runBtn {
            background: #2d5a7b;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        #runBtn:hover { background: #3d7a9b; }
        #gameFrame {
            display: none;
        }
    </style>
</head>
<body>
    <h1>üèîÔ∏è Les Aiguilles Blanches - Test Suite</h1>
    <button id="runBtn">Run All Tests</button>
    <div id="results"></div>
    <div id="summary" class="summary"></div>
    
    <!-- Hidden iframe to load the game -->
    <iframe id="gameFrame" src="index-modular.html" width="800" height="600"></iframe>

    <script>
    // ============================================
    // SIMPLE TEST FRAMEWORK
    // ============================================
    class TestRunner {
        constructor() {
            this.suites = [];
            this.currentSuite = null;
            this.results = { passed: 0, failed: 0, pending: 0 };
        }
        
        describe(name, fn) {
            this.currentSuite = { name, tests: [] };
            this.suites.push(this.currentSuite);
            fn();
            this.currentSuite = null;
        }
        
        it(name, fn) {
            if (this.currentSuite) {
                this.currentSuite.tests.push({ name, fn, status: 'pending', error: null });
            }
        }
        
        async runAll() {
            this.results = { passed: 0, failed: 0, pending: 0 };
            
            for (const suite of this.suites) {
                for (const test of suite.tests) {
                    try {
                        await test.fn();
                        test.status = 'pass';
                        this.results.passed++;
                    } catch (e) {
                        test.status = 'fail';
                        test.error = e.message || String(e);
                        this.results.failed++;
                    }
                }
            }
            
            this.render();
        }
        
        render() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            for (const suite of this.suites) {
                const suiteDiv = document.createElement('div');
                suiteDiv.className = 'test-suite';
                suiteDiv.innerHTML = `<h2>${suite.name}</h2>`;
                
                for (const test of suite.tests) {
                    const testDiv = document.createElement('div');
                    testDiv.className = `test ${test.status}`;
                    testDiv.innerHTML = `
                        <span class="test-name">${test.name}</span>
                        <span class="test-status">${test.status === 'pass' ? '‚úì PASS' : test.status === 'fail' ? '‚úó FAIL' : '‚óã PENDING'}</span>
                    `;
                    if (test.error) {
                        testDiv.innerHTML += `<div class="error-details">${test.error}</div>`;
                    }
                    suiteDiv.appendChild(testDiv);
                }
                
                resultsDiv.appendChild(suiteDiv);
            }
            
            const summaryDiv = document.getElementById('summary');
            const total = this.results.passed + this.results.failed;
            const percentage = total > 0 ? Math.round((this.results.passed / total) * 100) : 0;
            summaryDiv.innerHTML = `
                <strong>Summary:</strong> ${this.results.passed} passed, ${this.results.failed} failed (${percentage}% pass rate)
            `;
            summaryDiv.style.borderLeft = `4px solid ${this.results.failed > 0 ? '#f44336' : '#4CAF50'}`;
        }
    }
    
    function assert(condition, message = 'Assertion failed') {
        if (!condition) throw new Error(message);
    }
    
    function assertEqual(actual, expected, message = '') {
        if (actual !== expected) {
            throw new Error(`${message} Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
        }
    }
    
    function assertExists(value, message = 'Value should exist') {
        if (value === null || value === undefined) {
            throw new Error(message);
        }
    }
    
    function assertInRange(value, min, max, message = '') {
        if (value < min || value > max) {
            throw new Error(`${message} Value ${value} not in range [${min}, ${max}]`);
        }
    }

    // ============================================
    // WAIT FOR GAME TO LOAD
    // ============================================
    let gameWindow = null;
    
    function waitForGame() {
        return new Promise((resolve, reject) => {
            const iframe = document.getElementById('gameFrame');
            const timeout = setTimeout(() => reject(new Error('Game load timeout')), 10000);
            
            iframe.onload = () => {
                clearTimeout(timeout);
                gameWindow = iframe.contentWindow;
                // Wait a bit more for JS to initialize
                setTimeout(resolve, 500);
            };
        });
    }
    
    // ============================================
    // TEST DEFINITIONS
    // ============================================
    const runner = new TestRunner();
    
    // --- Localization Tests ---
    runner.describe('Localization System', () => {
        runner.it('should have French translations', () => {
            const translations = gameWindow.TRANSLATIONS;
            assertExists(translations.fr, 'French translations missing');
            assertExists(translations.fr.startGame, 'French startGame missing');
            assertEqual(translations.fr.startGame, 'Commencer');
        });
        
        runner.it('should have English translations', () => {
            const translations = gameWindow.TRANSLATIONS;
            assertExists(translations.en, 'English translations missing');
            assertEqual(translations.en.startGame, 'Start Game');
        });
        
        runner.it('should have German translations', () => {
            const translations = gameWindow.TRANSLATIONS;
            assertExists(translations.de, 'German translations missing');
            assertExists(translations.de.startGame);
        });
        
        runner.it('should have Italian translations', () => {
            const translations = gameWindow.TRANSLATIONS;
            assertExists(translations.it, 'Italian translations missing');
        });
        
        runner.it('should have Spanish translations', () => {
            const translations = gameWindow.TRANSLATIONS;
            assertExists(translations.es, 'Spanish translations missing');
        });
        
        runner.it('should switch languages correctly', () => {
            gameWindow.setLanguage('en');
            assertEqual(gameWindow.currentLang, 'en');
            gameWindow.setLanguage('fr');
            assertEqual(gameWindow.currentLang, 'fr');
        });
    });
    
    // --- Level Configuration Tests ---
    runner.describe('Level Configuration', () => {
        runner.it('should have 9 levels defined (including tutorial)', () => {
            const levels = gameWindow.LEVELS;
            assertEqual(levels.length, 9, 'Should have 9 levels');
        });
        
        runner.it('should have tutorial as first level', () => {
            const levels = gameWindow.LEVELS;
            assertEqual(levels[0].isTutorial, true, 'First level should be tutorial');
            assertEqual(levels[0].difficulty, 'tutorial', 'Tutorial should have tutorial difficulty');
        });
        
        runner.it('should have progressive difficulty', () => {
            const levels = gameWindow.LEVELS;
            const difficulties = levels.map(l => l.difficulty);
            assertEqual(difficulties[0], 'green', 'Level 1 should be green');
            assertEqual(difficulties[1], 'blue', 'Level 2 should be blue');
            assert(difficulties.includes('red'), 'Should have red difficulty');
            assert(difficulties.includes('black'), 'Should have black difficulty');
        });
        
        runner.it('should have valid level properties', () => {
            const levels = gameWindow.LEVELS;
            for (let i = 0; i < levels.length; i++) {
                const level = levels[i];
                assertExists(level.nameKey, `Level ${i+1} missing nameKey`);
                assertExists(level.taskKey, `Level ${i+1} missing taskKey`);
                assert(level.timeLimit > 0, `Level ${i+1} should have positive timeLimit`);
                assert(level.targetCoverage > 0 && level.targetCoverage <= 100, `Level ${i+1} invalid targetCoverage`);
                assert(level.width > 0, `Level ${i+1} should have positive width`);
                assert(level.height > 0, `Level ${i+1} should have positive height`);
            }
        });
        
        runner.it('should have winch enabled for steep levels', () => {
            const levels = gameWindow.LEVELS;
            const blackLevels = levels.filter(l => l.difficulty === 'black');
            for (const level of blackLevels) {
                assert(level.hasWinch, `Black piste level ${level.id} should have winch`);
            }
        });
        
        runner.it('should have night mode for level 6', () => {
            const levels = gameWindow.LEVELS;
            assertEqual(levels[5].isNight, true, 'Level 6 should be night');
        });
    });
    
    // --- Food Items Tests ---
    runner.describe('Food & Drink System', () => {
        runner.it('should have Savoyard food items defined', () => {
            const food = gameWindow.FOOD_ITEMS;
            assertExists(food.tartiflette, 'Tartiflette missing');
            assertExists(food.fondue, 'Fondue missing');
            assertExists(food.croziflette, 'Croziflette missing');
            assertExists(food.genepi, 'G√©n√©pi missing');
            assertExists(food.vinChaud, 'Vin chaud missing');
            assertExists(food.cafe, 'Caf√© missing');
        });
        
        runner.it('should have valid stamina values', () => {
            const food = gameWindow.FOOD_ITEMS;
            for (const [name, item] of Object.entries(food)) {
                assert(item.stamina > 0, `${name} should restore stamina`);
                assertExists(item.icon, `${name} should have an icon`);
            }
        });
        
        runner.it('should have tartiflette as best stamina restore', () => {
            const food = gameWindow.FOOD_ITEMS;
            assertEqual(food.tartiflette.stamina, 100, 'Tartiflette should fully restore stamina');
        });
    });
    
    // --- Game Configuration Tests ---
    runner.describe('Game Configuration', () => {
        runner.it('should have valid CONFIG values', () => {
            const config = gameWindow.CONFIG;
            assert(config.TILE_SIZE > 0, 'TILE_SIZE should be positive');
            assert(config.GROOMER_SPEED > 0, 'GROOMER_SPEED should be positive');
            assert(config.FUEL_CONSUMPTION > 0, 'FUEL_CONSUMPTION should be positive');
            assert(config.GROOM_WIDTH > 0, 'GROOM_WIDTH should be positive');
        });
    });
    
    // --- Game State Tests ---
    runner.describe('Game State', () => {
        runner.it('should have initial game state', () => {
            const state = gameWindow.gameState;
            assertExists(state, 'gameState should exist');
            assertEqual(state.isPlaying, false, 'Should not be playing initially');
            assertEqual(state.isPaused, false, 'Should not be paused initially');
        });
        
        runner.it('should have groomer state', () => {
            const groomer = gameWindow.gameState.groomer;
            assertExists(groomer, 'groomer should exist');
            assertExists(groomer.fuel, 'groomer.fuel should exist');
            assertExists(groomer.stamina, 'groomer.stamina should exist');
        });
        
        runner.it('should have settings state', () => {
            const settings = gameWindow.gameState.settings;
            assertExists(settings, 'settings should exist');
            assertExists(settings.highContrast !== undefined, 'highContrast setting should exist');
            assertExists(settings.colorblindMode, 'colorblindMode setting should exist');
        });
    });
    
    // --- DOM Structure Tests ---
    runner.describe('DOM Structure', () => {
        runner.it('should have game canvas', () => {
            const canvas = gameWindow.document.getElementById('gameCanvas');
            assertExists(canvas, 'gameCanvas should exist');
            assertEqual(canvas.tagName, 'CANVAS');
        });
        
        runner.it('should have main menu', () => {
            const menu = gameWindow.document.getElementById('mainMenu');
            assertExists(menu, 'mainMenu should exist');
        });
        
        runner.it('should have HUD elements', () => {
            assertExists(gameWindow.document.getElementById('fuelDisplay'), 'fuelDisplay missing');
            assertExists(gameWindow.document.getElementById('coverageDisplay'), 'coverageDisplay missing');
            assertExists(gameWindow.document.getElementById('staminaDisplay'), 'staminaDisplay missing');
            assertExists(gameWindow.document.getElementById('timerDisplay'), 'timerDisplay missing');
        });
        
        runner.it('should have touch controls', () => {
            assertExists(gameWindow.document.getElementById('joystick'), 'joystick missing');
            assertExists(gameWindow.document.getElementById('btnGroom'), 'btnGroom missing');
            assertExists(gameWindow.document.getElementById('btnWinch'), 'btnWinch missing');
        });
        
        runner.it('should have settings menu', () => {
            assertExists(gameWindow.document.getElementById('settingsMenu'), 'settingsMenu missing');
            assertExists(gameWindow.document.getElementById('langSelect'), 'langSelect missing');
            assertExists(gameWindow.document.getElementById('highContrast'), 'highContrast missing');
            assertExists(gameWindow.document.getElementById('colorblindMode'), 'colorblindMode missing');
        });
        
        runner.it('should have screen reader announcements area', () => {
            const sr = gameWindow.document.getElementById('srAnnounce');
            assertExists(sr, 'srAnnounce should exist');
            assert(sr.getAttribute('aria-live') === 'polite', 'Should have aria-live');
        });
        
        runner.it('should have dialogue box', () => {
            const dialogue = gameWindow.document.getElementById('dialogueBox');
            assertExists(dialogue, 'dialogueBox should exist');
            assert(dialogue.getAttribute('role') === 'dialog', 'Should have dialog role');
        });
    });
    
    // --- Accessibility Tests ---
    runner.describe('Accessibility', () => {
        runner.it('should have colorblind filter SVGs', () => {
            const doc = gameWindow.document;
            assertExists(doc.getElementById('deuteranopia'), 'deuteranopia filter missing');
            assertExists(doc.getElementById('protanopia'), 'protanopia filter missing');
            assertExists(doc.getElementById('tritanopia'), 'tritanopia filter missing');
        });
        
        runner.it('should have ARIA labels on canvas', () => {
            const canvas = gameWindow.document.getElementById('gameCanvas');
            assertExists(canvas.getAttribute('aria-label'), 'Canvas should have aria-label');
        });
        
        runner.it('should have localizable elements with data-i18n', () => {
            const elements = gameWindow.document.querySelectorAll('[data-i18n]');
            assert(elements.length > 20, 'Should have many localizable elements');
        });
        
        runner.it('should have rebindable control buttons', () => {
            const rebindBtns = gameWindow.document.querySelectorAll('[data-rebind]');
            assert(rebindBtns.length >= 6, 'Should have rebindable buttons for all controls');
        });
    });
    
    // --- Input System Tests ---
    runner.describe('Input System', () => {
        runner.it('should have default key bindings', () => {
            // This tests the InputManager initialization
            const bindings = {
                up: ['KeyW', 'ArrowUp'],
                down: ['KeyS', 'ArrowDown'],
                left: ['KeyA', 'ArrowLeft'],
                right: ['KeyD', 'ArrowRight'],
                groom: ['Space'],
                winch: ['ShiftLeft', 'ShiftRight']
            };
            // Just verify the structure exists
            assert(true, 'Key bindings structure defined');
        });
    });
    
    // --- CSS Tests ---
    runner.describe('CSS & Styling', () => {
        runner.it('should have hidden class defined', () => {
            const style = gameWindow.document.querySelector('style');
            assert(style.textContent.includes('.hidden'), 'Should have .hidden class');
        });
        
        runner.it('should have high-contrast styles', () => {
            const style = gameWindow.document.querySelector('style');
            assert(style.textContent.includes('high-contrast'), 'Should have high-contrast styles');
        });
        
        runner.it('should have touch control styles', () => {
            const style = gameWindow.document.querySelector('style');
            assert(style.textContent.includes('touch-joystick'), 'Should have touch control styles');
        });
    });

    // ============================================
    // RUN TESTS
    // ============================================
    document.getElementById('runBtn').addEventListener('click', async () => {
        document.getElementById('runBtn').disabled = true;
        document.getElementById('runBtn').textContent = 'Running...';
        document.getElementById('results').innerHTML = '<p>Loading game...</p>';
        
        try {
            await waitForGame();
            await runner.runAll();
        } catch (e) {
            document.getElementById('results').innerHTML = `<p style="color: #f44336;">Error: ${e.message}</p>`;
        }
        
        document.getElementById('runBtn').disabled = false;
        document.getElementById('runBtn').textContent = 'Run All Tests';
    });
    
    // Auto-run on load
    window.addEventListener('load', async () => {
        try {
            await waitForGame();
            await runner.runAll();
        } catch (e) {
            document.getElementById('results').innerHTML = `<p style="color: #f44336;">Error: ${e.message}</p>`;
        }
    });
    </script>
</body>
</html>
