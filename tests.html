<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Les Aiguilles Blanches - Phaser Tests</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #fff;
            padding: 20px;
        }
        h1 { margin-bottom: 20px; }
        .test-suite {
            background: #2a2a4e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .test-suite h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #87CEEB;
        }
        .test {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        .test.pass { background: #1a4a1a; }
        .test.fail { background: #4a1a1a; }
        .test-name { flex: 1; }
        .test-status { font-weight: bold; margin-left: 10px; }
        .pass .test-status { color: #4CAF50; }
        .fail .test-status { color: #f44336; }
        .error-details {
            width: 100%;
            font-size: 12px;
            color: #ff8888;
            margin-top: 5px;
            white-space: pre-wrap;
        }
        .summary {
            margin-top: 20px;
            padding: 15px;
            background: #2a2a4e;
            border-radius: 8px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <h1>üèîÔ∏è Les Aiguilles Blanches - Phaser Tests</h1>
    <div id="results"></div>
    <div id="summary" class="summary"></div>

    <!-- Load config files only (no Phaser needed for these tests) -->
    <script src="src/config/gameConfig.js"></script>
    <script src="src/config/levels.js"></script>
    <script src="src/config/localization.js"></script>

    <script>
    // Simple test framework
    const results = { passed: 0, failed: 0, tests: [] };

    function test(name, fn) {
        try {
            fn();
            results.passed++;
            results.tests.push({ name, status: 'pass' });
        } catch (e) {
            results.failed++;
            results.tests.push({ name, status: 'fail', error: e.message });
        }
    }

    function assert(condition, message) {
        if (!condition) throw new Error(message || 'Assertion failed');
    }

    function assertEqual(actual, expected, message) {
        if (actual !== expected) {
            throw new Error(`${message || ''} Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
        }
    }

    // ============================================
    // LEVEL CONFIGURATION TESTS
    // ============================================

    test('LEVELS array exists and has 9 levels', () => {
        assert(Array.isArray(LEVELS), 'LEVELS should be an array');
        assertEqual(LEVELS.length, 9, 'Should have 9 levels');
    });

    test('All levels have required base properties', () => {
        const requiredProps = ['id', 'nameKey', 'taskKey', 'difficulty', 'timeLimit', 
                               'targetCoverage', 'width', 'height'];
        LEVELS.forEach((level, i) => {
            requiredProps.forEach(prop => {
                assert(level[prop] !== undefined, `Level ${i} missing ${prop}`);
            });
        });
    });

    test('All levels have piste configuration', () => {
        LEVELS.forEach((level, i) => {
            assert(level.pisteShape !== undefined, `Level ${i} missing pisteShape`);
            assert(level.pisteWidth !== undefined, `Level ${i} missing pisteWidth`);
            assert(level.pisteWidth > 0 && level.pisteWidth <= 1, 
                   `Level ${i} pisteWidth should be between 0 and 1`);
        });
    });

    test('All levels have steepZones array', () => {
        LEVELS.forEach((level, i) => {
            assert(Array.isArray(level.steepZones), `Level ${i} missing steepZones array`);
        });
    });

    test('All levels have winchAnchors array', () => {
        LEVELS.forEach((level, i) => {
            assert(Array.isArray(level.winchAnchors), `Level ${i} missing winchAnchors array`);
        });
    });

    test('All levels have obstacles array', () => {
        LEVELS.forEach((level, i) => {
            assert(Array.isArray(level.obstacles), `Level ${i} missing obstacles array`);
        });
    });

    test('Winch levels have anchors defined', () => {
        LEVELS.forEach((level, i) => {
            if (level.hasWinch) {
                // Winch levels should have at least winchAnchors array (can be empty for default)
                assert(Array.isArray(level.winchAnchors), 
                       `Level ${i} has winch but no winchAnchors`);
            }
        });
    });

    test('Steep zones have valid properties', () => {
        LEVELS.forEach((level, i) => {
            level.steepZones.forEach((zone, j) => {
                assert(typeof zone.startY === 'number', 
                       `Level ${i} zone ${j} missing startY`);
                assert(typeof zone.endY === 'number', 
                       `Level ${i} zone ${j} missing endY`);
                assert(typeof zone.slope === 'number', 
                       `Level ${i} zone ${j} missing slope`);
                assert(zone.startY >= 0 && zone.startY <= 1, 
                       `Level ${i} zone ${j} startY should be 0-1`);
                assert(zone.endY >= 0 && zone.endY <= 1, 
                       `Level ${i} zone ${j} endY should be 0-1`);
                assert(zone.startY < zone.endY, 
                       `Level ${i} zone ${j} startY should be < endY`);
            });
        });
    });

    test('Winch anchors have valid properties', () => {
        LEVELS.forEach((level, i) => {
            level.winchAnchors.forEach((anchor, j) => {
                assert(typeof anchor.y === 'number', 
                       `Level ${i} anchor ${j} missing y`);
                assert(anchor.y >= 0 && anchor.y <= 1, 
                       `Level ${i} anchor ${j} y should be 0-1`);
            });
        });
    });

    test('Level 0 is tutorial', () => {
        assertEqual(LEVELS[0].isTutorial, true, 'Level 0 should be tutorial');
        assertEqual(LEVELS[0].difficulty, 'tutorial', 'Level 0 difficulty');
    });

    test('Progressive difficulty ordering', () => {
        const difficultyOrder = { tutorial: 0, green: 1, blue: 2, park: 3, red: 4, black: 5 };
        let maxDifficulty = 0;
        LEVELS.forEach((level, i) => {
            const diff = difficultyOrder[level.difficulty] || 0;
            // Allow same or higher difficulty
            assert(diff >= maxDifficulty - 1, 
                   `Level ${i} difficulty ${level.difficulty} seems out of order`);
            maxDifficulty = Math.max(maxDifficulty, diff);
        });
    });

    // ============================================
    // LOCALIZATION TESTS
    // ============================================

    test('All 5 languages exist', () => {
        ['fr', 'en', 'de', 'it', 'es'].forEach(lang => {
            assert(TRANSLATIONS[lang], `Missing ${lang} translations`);
        });
    });

    test('All level names are translated in FR and EN', () => {
        LEVELS.forEach((level, i) => {
            assert(TRANSLATIONS.fr[level.nameKey], 
                   `Missing FR translation for ${level.nameKey}`);
            assert(TRANSLATIONS.en[level.nameKey], 
                   `Missing EN translation for ${level.nameKey}`);
        });
    });

    test('Hazard messages exist in FR and EN', () => {
        const hazards = ['cliffFall', 'fuelEmpty', 'avalancheWarning', 
                         'avalancheTrigger', 'steepWarning', 'tumble'];
        hazards.forEach(h => {
            assert(TRANSLATIONS.fr[h], `Missing FR translation for ${h}`);
            assert(TRANSLATIONS.en[h], `Missing EN translation for ${h}`);
        });
    });

    // ============================================
    // GAME CONFIG TESTS
    // ============================================

    test('GAME_CONFIG exists with required values', () => {
        assert(GAME_CONFIG, 'GAME_CONFIG should exist');
        assert(GAME_CONFIG.GROOMER_SPEED > 0, 'GROOMER_SPEED should be positive');
        assert(GAME_CONFIG.FUEL_CONSUMPTION > 0, 'FUEL_CONSUMPTION should be positive');
        assert(GAME_CONFIG.GROOM_WIDTH > 0, 'GROOM_WIDTH should be positive');
    });

    // ============================================
    // PISTE PATH SIMULATION TEST
    // ============================================

    test('Piste path generation works for all shapes', () => {
        const shapes = ['straight', 'gentle_curve', 'winding', 'serpentine', 'wide'];
        shapes.forEach(shape => {
            const level = { 
                width: 30, 
                height: 50, 
                pisteShape: shape, 
                pisteWidth: 0.5 
            };
            
            // Simulate generatePistePath logic
            const pisteWidth = level.pisteWidth || 0.5;
            const worldWidth = level.width;
            const worldHeight = level.height;
            const halfWidth = Math.floor(worldWidth * pisteWidth / 2);
            
            const pistePath = [];
            for (let y = 0; y < worldHeight; y++) {
                const progress = y / worldHeight;
                let centerX = worldWidth / 2;
                let width = halfWidth * 2;
                
                switch (shape) {
                    case 'straight':
                        break;
                    case 'gentle_curve':
                        centerX += Math.sin(progress * Math.PI * 2) * (worldWidth * 0.15);
                        break;
                    case 'winding':
                        centerX += Math.sin(progress * Math.PI * 3) * (worldWidth * 0.2);
                        width = halfWidth * 2 * (0.8 + 0.2 * Math.cos(progress * Math.PI * 3));
                        break;
                    case 'serpentine':
                        centerX += Math.sin(progress * Math.PI * 4) * (worldWidth * 0.25);
                        width = halfWidth * 2 * (0.7 + 0.3 * Math.abs(Math.cos(progress * Math.PI * 4)));
                        break;
                    case 'wide':
                        width = halfWidth * 2.5;
                        break;
                }
                
                pistePath.push({
                    centerX: Math.max(halfWidth + 3, Math.min(worldWidth - halfWidth - 3, centerX)),
                    width: Math.max(6, Math.floor(width))
                });
            }
            
            assertEqual(pistePath.length, worldHeight, `${shape} path length`);
            pistePath.forEach((path, y) => {
                assert(path.centerX >= 0 && path.centerX <= worldWidth, 
                       `${shape} y=${y} centerX out of bounds`);
                assert(path.width >= 6, `${shape} y=${y} width too small`);
            });
        });
    });

    // ============================================
    // RENDER RESULTS
    // ============================================

    function render() {
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';

        const suiteDiv = document.createElement('div');
        suiteDiv.className = 'test-suite';
        suiteDiv.innerHTML = '<h2>Configuration Tests</h2>';

        results.tests.forEach(t => {
            const testDiv = document.createElement('div');
            testDiv.className = `test ${t.status}`;
            testDiv.innerHTML = `
                <span class="test-name">${t.name}</span>
                <span class="test-status">${t.status === 'pass' ? '‚úì PASS' : '‚úó FAIL'}</span>
            `;
            if (t.error) {
                testDiv.innerHTML += `<div class="error-details">${t.error}</div>`;
            }
            suiteDiv.appendChild(testDiv);
        });

        resultsDiv.appendChild(suiteDiv);

        const total = results.passed + results.failed;
        const pct = Math.round((results.passed / total) * 100);
        document.getElementById('summary').innerHTML = `
            <strong>Summary:</strong> ${results.passed} passed, ${results.failed} failed (${pct}%)
        `;
        document.getElementById('summary').style.borderLeft = 
            `4px solid ${results.failed > 0 ? '#f44336' : '#4CAF50'}`;
    }

    render();
    </script>
</body>
</html>
